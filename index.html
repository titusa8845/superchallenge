<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>超級大挑戰 - Rhythm Sync System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');

        body {
            font-family: 'Inter', "Microsoft JhengHei", sans-serif;
            background-color: #09090b;
            color: white;
            user-select: none;
        }

        /* 遊戲格子樣式 */
        .grid-item {
            transition: all 0.1s ease-out;
            border: 2px solid #27272a;
        }

        .grid-item.active {
            border-color: transparent;
            box-shadow: 0 0 50px rgba(220, 38, 38, 0.8);
            transform: scale(1.1);
            z-index: 20;
            outline: 8px solid #dc2626;
        }

        /* 標題節奏動畫 */
        .title-beat {
            transform: scale(1.1);
            color: #dc2626;
            text-shadow: 0 0 20px rgba(220, 38, 38, 0.8);
        }

        /* 圖片庫樣式 */
        .tray-item {
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .tray-item:hover {
            transform: translateY(-5px);
            border-color: #52525b;
        }

        .tray-item.selected {
            border-color: #3b82f6;
            /* 藍色選中框 */
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
            transform: scale(1.05);
        }

        /* 捲軸美化 */
        .custom-scrollbar::-webkit-scrollbar {
            height: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #18181b;
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #3f3f46;
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #52525b;
        }

        input[type="file"] {
            display: none;
        }
    </style>
</head>

<body class="h-screen flex flex-col overflow-hidden">

    <!-- YouTube Loader -->
    <div id="youtube-loader" class="fixed top-0 left-0 w-full z-[100] transition-all duration-500 pointer-events-none">
        <div class="w-full h-1 bg-blue-600/30 overflow-hidden">
            <div class="w-full h-full bg-blue-500 animate-[loading-bar_1.5s_ease-in-out_infinite]"></div>
        </div>
        <div class="flex justify-center mt-2">
            <span
                class="bg-black/80 text-blue-200 text-xs font-bold px-4 py-1.5 rounded-full border border-blue-500/30 shadow-lg tracking-widest flex items-center gap-2">
                <svg class="animate-spin h-3 w-3 text-blue-400" xmlns="http://www.w3.org/2000/svg" fill="none"
                    viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                    </path>
                </svg>
                YOUTUBE影片Wordonbeat載入中
            </span>
        </div>
    </div>

    <!-- 頂部資訊列 (浮動) -->
    <div class="fixed top-0 left-0 w-full p-4 flex justify-between items-start z-50 pointer-events-none">
        <div class="pointer-events-auto bg-black/30 backdrop-blur-md p-3 rounded-2xl border border-white/10 shadow-xl transition-all duration-500"
            id="header-panel">
            <h1 id="main-title"
                class="text-4xl md:text-6xl font-black italic tracking-tighter text-white transition-all duration-300 drop-shadow-[0_0_15px_rgba(255,255,255,0.3)]">
                超級大挑戰
            </h1>
            <div class="flex items-baseline gap-2">
                <span class="text-sm font-bold text-zinc-400 italic tracking-widest">by 小萬</span>
            </div>
        </div>

        <!-- 回合指示器 -->
        <div id="round-indicators"
            class="pointer-events-auto flex gap-1 bg-black/30 backdrop-blur-md p-1.5 rounded-2xl border border-white/10 shadow-lg transition-all duration-500">
            <button onclick="setRound(0)" id="round-btn-0"
                class="round-btn w-10 h-10 rounded-xl bg-zinc-800/50 text-zinc-400 font-bold hover:bg-zinc-700/80 transition-all border border-white/5 text-sm">1</button>
            <button onclick="setRound(1)" id="round-btn-1"
                class="round-btn w-10 h-10 rounded-xl bg-zinc-800/50 text-zinc-400 font-bold hover:bg-zinc-700/80 transition-all border border-white/5 text-sm">2</button>
            <button onclick="setRound(2)" id="round-btn-2"
                class="round-btn w-10 h-10 rounded-xl bg-zinc-800/50 text-zinc-400 font-bold hover:bg-zinc-700/80 transition-all border border-white/5 text-sm">3</button>
            <button onclick="setRound(3)" id="round-btn-3"
                class="round-btn w-10 h-10 rounded-xl bg-zinc-800/50 text-zinc-400 font-bold hover:bg-zinc-700/80 transition-all border border-white/5 text-sm">4</button>
            <button onclick="setRound(4)" id="round-btn-4"
                class="round-btn w-10 h-10 rounded-xl bg-zinc-800/50 text-zinc-400 font-bold hover:bg-zinc-700/80 transition-all border border-white/5 text-sm">5</button>
        </div>
    </div>

    <!-- 主遊戲區 (全螢幕 + 模式切換) -->
    <div class="absolute inset-0 z-0 flex flex-col items-center justify-center transition-all duration-700 ease-[cubic-bezier(0.34,1.56,0.64,1)]"
        id="game-container">
        <div id="game-grid"
            class="grid grid-cols-4 grid-rows-2 gap-3 md:gap-4 p-4 transition-all duration-700 w-[75%] h-[55%]">
            <!-- 格子由 JS 動態生成 -->
        </div>
    </div>

    <!-- 播放控制按鈕 (懸浮右下) -->
    <div class="fixed right-6 bottom-40 z-40 flex flex-col gap-3 transition-all duration-500" id="control-panel">
        <button id="play-btn" disabled
            class="w-20 h-20 bg-white/10 backdrop-blur-md rounded-full flex items-center justify-center border border-white/20 hover:scale-110 active:scale-95 transition-all text-white disabled:opacity-50 disabled:cursor-not-allowed group shadow-2xl">
            <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"
                fill="currentColor">
                <polygon points="5 3 19 12 5 21 5 3" />
            </svg>
            <svg id="pause-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="32" height="32"
                viewBox="0 0 24 24" fill="currentColor">
                <rect x="6" y="4" width="4" height="16" />
                <rect x="14" y="4" width="4" height="16" />
            </svg>
            <div id="loading-spinner"
                class="hidden absolute inset-0 rounded-full border-2 border-t-red-500 border-r-transparent border-b-zinc-800 border-l-transparent animate-spin">
            </div>
        </button>
        <button id="reset-btn"
            class="w-12 h-12 bg-black/50 backdrop-blur rounded-full flex items-center justify-center border border-white/10 hover:bg-zinc-800 text-zinc-400 hover:text-white transition-colors shadow-lg">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                <path d="M3 3v5h5" />
            </svg>
        </button>
    </div>

    <!-- 底部素材庫抽屜 (Fixed Drawer) -->
    <div id="bottom-drawer"
        class="fixed bottom-0 left-0 w-full bg-black/90 backdrop-blur-xl border-t border-white/10 flex flex-col shrink-0 z-50 transition-transform duration-500 ease-out translate-y-0 shadow-[0_-10px_40px_rgba(0,0,0,0.8)]">

        <!-- Drawer Toggle Handle -->
        <div class="absolute -top-6 left-1/2 -translate-x-1/2 w-32 h-6 bg-black/90 backdrop-blur-xl rounded-t-xl border-t border-l border-r border-white/10 flex items-center justify-center cursor-pointer hover:bg-zinc-800 transition-colors group"
            onclick="toggleDrawer()">
            <svg id="drawer-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2"
                class="text-zinc-400 group-hover:text-white transition-transform duration-300">
                <polyline points="6 9 12 15 18 9" />
            </svg>
        </div>

        <div class="px-6 py-3 flex justify-between items-center border-b border-white/5 bg-white/5">
            <div class="flex items-center gap-6">
                <!-- Spotlight Toggle Switch -->
                <label for="spotlight-toggle" class="flex items-center cursor-pointer relative group">
                    <input type="checkbox" id="spotlight-toggle" class="sr-only peer" checked>
                    <div
                        class="w-9 h-5 bg-zinc-700 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-800 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600">
                    </div>
                    <span
                        class="ml-2 text-xs font-bold text-zinc-400 uppercase tracking-widest peer-checked:text-white transition-colors group-hover:text-zinc-300">聚光燈</span>
                </label>

                <!-- Playback Speed -->
                <div class="flex items-center gap-2 border-l border-white/10 pl-6">
                    <span class="text-xs font-bold text-zinc-400 uppercase tracking-widest">速度</span>
                    <select id="speed-select"
                        class="bg-zinc-800 text-zinc-300 text-xs font-mono border border-zinc-600 rounded px-2 py-0.5 focus:outline-none focus:border-blue-500 cursor-pointer hover:bg-zinc-700 transition-colors appearance-none text-center w-16">
                        <option value="0.25">0.25x</option>
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1.0" selected>1.0x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2.0">2.0x</option>
                    </select>
                </div>
            </div>

            <div class="flex gap-3">
                <div
                    class="hidden md:flex text-[10px] text-zinc-500 font-mono items-center mr-2 border border-dashed border-zinc-700 px-2 rounded">
                    DRAG & DROP READY
                </div>
                <button onclick="document.getElementById('upload-input').click()"
                    class="text-xs bg-blue-600/20 hover:bg-blue-600/40 border border-blue-500/30 px-4 py-1.5 rounded-lg text-blue-200 transition-all flex items-center gap-2 hover:scale-105 active:scale-95">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                        <polyline points="17 8 12 3 7 8" />
                        <line x1="12" y1="3" x2="12" y2="15" />
                    </svg>
                    上傳
                </button>
                <button onclick="clearTraySelection()"
                    class="text-xs text-zinc-500 hover:text-white px-3 transition-colors">清除選取</button>
            </div>
            <input type="file" id="upload-input" multiple accept="image/*" class="hidden">
        </div>

        <div id="image-tray"
            class="h-32 w-full overflow-x-auto overflow-y-hidden p-4 flex gap-4 custom-scrollbar items-center bg-zinc-950/50 transition-colors">
            <div
                class="text-zinc-600 text-sm italic px-8 pointer-events-none select-none flex items-center gap-3 w-full justify-center opacity-50">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="1.5">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                    <polyline points="17 8 12 3 7 8" />
                    <line x1="12" y1="3" x2="12" y2="15" />
                </svg>
                拖曳圖片至此處，或點擊上傳按鈕
            </div>
        </div>
    </div>

    <!-- YouTube 隱藏播放器 -->
    <div id="youtube-player" class="fixed opacity-0 pointer-events-none -z-50 w-1 h-1 bottom-0 left-0"></div>

    <style>
        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            height: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.02);
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        @keyframes loading-bar {
            0% {
                transform: translateX(-100%);
            }

            50% {
                transform: translateX(0%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .grid-item.active {
            border: 4px solid #ef4444 !important;
            box-shadow: 0 0 40px #ef4444, inset 0 0 20px #ef4444;
            transform: scale(1.05);
            z-index: 20;
        }

        /* Spotlight Effect (Optional: Whiten/Flash) */
        .spotlight-mode .grid-item.active {
            filter: brightness(1.8) contrast(1.1) sepia(0.2);
            box-shadow: 0 0 40px #ef4444, inset 0 0 50px rgba(255, 255, 255, 0.5);
        }

        /* 3D Flip Effect */
        .perspective-1000 {
            perspective: 1000px;
        }

        .transform-style-3d {
            transform-style: preserve-3d;
        }

        .backface-hidden {
            backface-visibility: hidden;
        }

        .rotate-y-180 {
            transform: rotateY(180deg);
        }

        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
            transform-style: preserve-3d;
        }

        .flip-card-front,
        .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 1rem;
            /* rounded-2xl */
            overflow: hidden;
        }

        .flip-card-back {
            transform: rotateY(180deg);
        }

        /* When 'flipped' class is present, rotate the inner container */
        .grid-item.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .tray-drag-over {
            background-color: rgba(59, 130, 246, 0.1) !important;
            border: 2px dashed rgba(59, 130, 246, 0.5);
            box-shadow: inset 0 0 20px rgba(59, 130, 246, 0.2);
        }

        /* Mode Styles managed via JS classes on container */
        .mode-standby #game-grid {
            width: 75%;
            height: 55%;
            transform: perspective(1000px) rotateX(2deg);
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 24px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .mode-playing #game-grid {
            width: 95%;
            height: 90%;
            transform: perspective(1000px) rotateX(0deg);
            background: transparent;
            border: none;
            box-shadow: none;
        }

        .drawer-closed {
            transform: translateY(100%);
        }

        .drawer-open {
            transform: translateY(0%);
        }

        .flip-icon {
            transform: rotate(180deg);
        }
    </style>

    <script>
        // --- 核心設定 ---
        let BPM = 173;
        let BEAT_DURATION = 60 / BPM;

        const TOTAL_ROUNDS = 5;
        const SLOTS_PER_ROUND = 8;

        const GAME_STATE = {
            currentRound: 0,
            rounds: Array.from({ length: TOTAL_ROUNDS }, () => ({
                images: Array(SLOTS_PER_ROUND).fill(null)
            })),
            activeTrayImage: null,
            isPlaying: false,
            animationFrameId: null,
            lastBeat: -1,
            globalOffset: 0,
            isDrawerOpen: true
        };

        const RHYTHM_TIMELINE = [
            { time: 0.0, action: 'stop', round: 0 },
            { time: 5.3, action: 'start', round: 0 },
            { time: 10.6, action: 'start', round: 1 },
            { time: 15.9, action: 'start', round: 2 },
            { time: 21.1, action: 'start', round: 3 },
            { time: 26.4, action: 'start', round: 4 },
            { time: 999.0, action: 'stop' }
        ];

        // --- DOM Elements ---
        const gridEl = document.getElementById('game-grid');
        const gameContainer = document.getElementById('game-container');
        const trayEl = document.getElementById('image-tray');
        const uploadInput = document.getElementById('upload-input');
        const drawerEl = document.getElementById('bottom-drawer');
        const drawerIcon = document.getElementById('drawer-icon');
        const spotlightToggle = document.getElementById('spotlight-toggle');
        const speedSelect = document.getElementById('speed-select');

        function init() {
            renderGrid();
            setupTrayEvents();
            updateRoundButtons();
            setGameMode('standby'); // default

            // Spotlight Toggle
            if (spotlightToggle) {
                spotlightToggle.addEventListener('change', (e) => {
                    toggleSpotlight(e.target.checked);
                });
                toggleSpotlight(spotlightToggle.checked);
            }

            // Playback Speed
            if (speedSelect) {
                speedSelect.addEventListener('change', (e) => {
                    const rate = parseFloat(e.target.value);
                    if (player && player.setPlaybackRate) {
                        player.setPlaybackRate(rate);
                    }
                });
            }
        }

        function toggleSpotlight(enabled) {
            if (enabled) {
                gridEl.classList.add('spotlight-mode');
            } else {
                gridEl.classList.remove('spotlight-mode');
            }
        }

        // --- View Mode & Drawer Logic ---
        function setGameMode(mode) {
            const header = document.getElementById('header-panel');
            const roundIndicators = document.getElementById('round-indicators');
            // const controls = document.getElementById('control-panel'); // Kept for reference

            if (mode === 'playing') {
                gameContainer.classList.remove('mode-standby');
                gameContainer.classList.add('mode-playing');
                toggleDrawer(false); // Auto close drawer

                // Visual tweaks for playing: HIDDEN
                header.classList.add('opacity-0', 'pointer-events-none', '-translate-y-10');
                roundIndicators.classList.add('opacity-0', 'pointer-events-none', '-translate-y-10');

            } else {
                gameContainer.classList.remove('mode-playing');
                gameContainer.classList.add('mode-standby');
                toggleDrawer(true); // Auto open drawer

                // Visual tweaks for standby: VISIBLE
                header.classList.remove('opacity-0', 'pointer-events-none', '-translate-y-10');
                roundIndicators.classList.remove('opacity-0', 'pointer-events-none', '-translate-y-10');
            }
        }

        function toggleDrawer(forceState = null) {
            const shouldOpen = forceState !== null ? forceState : !GAME_STATE.isDrawerOpen;
            GAME_STATE.isDrawerOpen = shouldOpen;

            if (shouldOpen) {
                drawerEl.classList.remove('drawer-closed');
                drawerIcon.classList.remove('flip-icon'); // arrow down
            } else {
                drawerEl.classList.add('drawer-closed');
                drawerIcon.classList.add('flip-icon'); // arrow up
            }
        }

        // --- UI Rendering ---
        function renderGrid() {
            gridEl.innerHTML = '';
            const images = GAME_STATE.rounds[GAME_STATE.currentRound].images;

            images.forEach((imgSrc, index) => {
                const slot = document.createElement('div');
                slot.id = `slot-${index}`;
                // perspective container
                slot.className = `grid-item perspective-1000 w-full h-full relative group cursor-pointer`;

                // Flip Inner
                const inner = document.createElement('div');
                inner.className = 'flip-card-inner w-full h-full shadow-inner rounded-2xl';

                // --- FRONT FACE ---
                const front = document.createElement('div');
                front.className = 'flip-card-front bg-zinc-800/80 flex items-center justify-center border-2 border-white/5';

                if (imgSrc) {
                    front.innerHTML = `<img src="${imgSrc}" class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-500">
                                       <div class="absolute inset-0 bg-black/0 group-hover:bg-white/10 transition-colors"></div>`;
                } else {
                    front.innerHTML = `<span class="text-white/10 font-black text-6xl md:text-9xl select-none group-hover:text-white/20 transition-colors italic">#${index + 1}</span>`;
                }

                // --- BACK FACE ---
                const back = document.createElement('div');
                back.className = 'flip-card-back bg-zinc-800/80 flex items-center justify-center border-2 border-white/5';
                back.innerHTML = `<div class="w-full h-full bg-zinc-900 flex items-center justify-center"><span class="animate-pulse text-zinc-500">Loading...</span></div>`;

                inner.appendChild(front);
                inner.appendChild(back);
                slot.appendChild(inner);

                slot.onclick = () => handleSlotClick(index);
                gridEl.appendChild(slot);
            });
        }

        // Helper to update the "Back" face with the content of a specific round
        function prepareFlipContent(targetRoundIndex) {
            const nextImages = GAME_STATE.rounds[targetRoundIndex].images;
            const slots = document.querySelectorAll('.grid-item');

            slots.forEach((slot, index) => {
                const inner = slot.querySelector('.flip-card-inner');
                if (!inner) return;

                const isFlipped = slot.classList.contains('flipped');
                // Target the hidden face
                const targetFace = isFlipped ? inner.querySelector('.flip-card-front') : inner.querySelector('.flip-card-back');

                const imgSrc = nextImages[index];
                if (imgSrc) {
                    targetFace.innerHTML = `<img src="${imgSrc}" class="w-full h-full object-cover">
                                            <div class="absolute inset-0 bg-black/0 group-hover:bg-white/10 transition-colors"></div>`;
                } else {
                    targetFace.innerHTML = `<span class="text-white/10 font-black text-6xl md:text-9xl select-none group-hover:text-white/20 transition-colors italic">#${index + 1}</span>`;
                }
            });
        }

        // Execute the flip animation
        function triggerFlip() {
            const slots = document.querySelectorAll('.grid-item');
            slots.forEach(slot => {
                slot.classList.toggle('flipped');
            });
        }

        function updateRoundButtons() {
            for (let i = 0; i < TOTAL_ROUNDS; i++) {
                const btn = document.getElementById(`round-btn-${i}`);
                if (i === GAME_STATE.currentRound) {
                    btn.className = 'round-btn w-10 h-10 rounded-xl bg-blue-600 text-white font-bold shadow-[0_0_20px_rgba(37,99,235,0.5)] scale-110 transition-all border border-blue-400 text-sm z-10';
                } else {
                    btn.className = 'round-btn w-10 h-10 rounded-xl bg-zinc-800/50 text-zinc-400 font-bold hover:bg-zinc-700/80 transition-all border border-white/5 text-sm hover:text-white';
                }
            }
        }

        function handleSlotClick(index) {
            const currentImg = GAME_STATE.rounds[GAME_STATE.currentRound].images[index];

            if (GAME_STATE.activeTrayImage) {
                // If tray has selection, ALWAYS overwrite (set image)
                GAME_STATE.rounds[GAME_STATE.currentRound].images[index] = GAME_STATE.activeTrayImage;
            } else if (currentImg) {
                // If NO tray selection but image exists, clear it (toggle off)
                GAME_STATE.rounds[GAME_STATE.currentRound].images[index] = null;
            }

            // Re-render logic that preserves flip state
            const slot = document.getElementById(`slot-${index}`);
            const isFlipped = slot.classList.contains('flipped');

            // We just need to update the visible face
            const inner = slot.querySelector('.flip-card-inner');
            const targetFace = isFlipped ? inner.querySelector('.flip-card-back') : inner.querySelector('.flip-card-front');
            const newImg = GAME_STATE.rounds[GAME_STATE.currentRound].images[index];

            if (newImg) {
                targetFace.innerHTML = `<img src="${newImg}" class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-500">
                                        <div class="absolute inset-0 bg-black/0 group-hover:bg-white/10 transition-colors"></div>`;
            } else {
                targetFace.innerHTML = `<span class="text-white/10 font-black text-6xl md:text-9xl select-none group-hover:text-white/20 transition-colors italic">#${index + 1}</span>`;
            }
        }

        function setRound(roundIndex) {
            GAME_STATE.currentRound = roundIndex;
            updateRoundButtons();

            // Reset to Front view when manually changing rounds (to keep things simple)
            renderGrid(); // renderGrid creates fresh DOM, defaulting to Front

            updateRhythmEffect(-1);
            GAME_STATE.hasFlippedForThisRound = false;
        }

        // --- Image Tray Logic ---
        function setupTrayEvents() {
            trayEl.addEventListener('dragover', (e) => { e.preventDefault(); trayEl.classList.add('tray-drag-over'); });
            trayEl.addEventListener('dragleave', (e) => { e.preventDefault(); trayEl.classList.remove('tray-drag-over'); });
            trayEl.addEventListener('drop', (e) => {
                e.preventDefault();
                trayEl.classList.remove('tray-drag-over');
                handleFiles(e.dataTransfer.files);
            });
            uploadInput.addEventListener('change', (e) => { handleFiles(e.target.files); uploadInput.value = ''; });
        }

        function handleFiles(files) {
            if (!files.length) return;
            const hint = trayEl.querySelector('.italic');
            if (hint) hint.remove();

            Array.from(files).forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (evt) => addImageToTray(evt.target.result);
                    reader.readAsDataURL(file);
                }
            });
        }

        function addImageToTray(src) {
            const div = document.createElement('div');
            div.className = 'tray-item w-28 h-24 bg-zinc-800 rounded-xl shrink-0 cursor-pointer overflow-hidden relative border-2 border-transparent hover:border-zinc-500 transition-all group';
            div.innerHTML = `<img src="${src}" class="w-full h-full object-cover group-hover:scale-110 transition-transform">`;
            div.onclick = () => {
                const prev = trayEl.querySelector('.border-blue-500');
                if (prev) {
                    prev.classList.remove('border-blue-500', 'shadow-[0_0_20px_rgba(59,130,246,0.6)]', 'scale-105', 'z-10');
                    prev.classList.add('border-transparent');
                }
                if (GAME_STATE.activeTrayImage === src) {
                    GAME_STATE.activeTrayImage = null;
                } else {
                    div.classList.remove('border-transparent');
                    div.classList.add('border-blue-500', 'shadow-[0_0_20px_rgba(59,130,246,0.6)]', 'scale-105', 'z-10');
                    GAME_STATE.activeTrayImage = src;
                }
            };
            trayEl.appendChild(div);
        }

        function clearTraySelection() {
            const prev = trayEl.querySelector('.border-blue-500');
            if (prev) {
                prev.classList.remove('border-blue-500', 'shadow-[0_0_20px_rgba(59,130,246,0.6)]', 'scale-105', 'z-10');
                prev.classList.add('border-transparent');
            }
            GAME_STATE.activeTrayImage = null;
        }

        // --- YouTube API ---
        let player;
        window.onYouTubeIframeAPIReady = function () {
            player = new YT.Player('youtube-player', {
                height: '100%', width: '100%', videoId: 'JtY2bm5Y-UY',
                playerVars: { 'playsinline': 1, 'controls': 0, 'disablekb': 1 },
                events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateChange }
            });
        };

        function onPlayerReady() {
            const playBtn = document.getElementById('play-btn');
            document.getElementById('loading-spinner').classList.add('hidden');
            // Hide Top Loader
            document.getElementById('youtube-loader').classList.add('opacity-0', '-translate-y-full');

            playBtn.disabled = false;
        }

        function onPlayerStateChange(event) {
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            const playBtn = document.getElementById('play-btn');
            const loader = document.getElementById('youtube-loader');

            // Handle Buffering
            if (event.data === YT.PlayerState.BUFFERING) {
                loader.classList.remove('opacity-0', '-translate-y-full');
            } else {
                loader.classList.add('opacity-0', '-translate-y-full');
            }

            if (event.data === YT.PlayerState.PLAYING) {
                GAME_STATE.isPlaying = true;
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
                playBtn.classList.add('border-red-500', 'bg-red-600/20', 'animate-pulse');
                setGameMode('playing');
                loop();
            } else {
                GAME_STATE.isPlaying = false;
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                playBtn.classList.remove('border-red-500', 'bg-red-600/20', 'animate-pulse');

                // If stopped or paused, go back to standby
                if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED || event.data === YT.PlayerState.CUED) {
                    setGameMode('standby');
                }

                if (GAME_STATE.animationFrameId) cancelAnimationFrame(GAME_STATE.animationFrameId);
            }
        }

        // --- Game Loop ---
        function loop() {
            if (!GAME_STATE.isPlaying) return;
            if (player && player.getCurrentTime) {
                let currentTime = player.getCurrentTime();
                const adjustedTime = currentTime - (GAME_STATE.globalOffset / 1000);
                updateGameLogic(adjustedTime < 0 ? 0 : adjustedTime);
                // document.getElementById('timer-display').innerText = `TIME: ${currentTime.toFixed(2)}s`;
            }
            GAME_STATE.animationFrameId = requestAnimationFrame(loop);
        }

        function updateGameLogic(time) {
            const title = document.getElementById('main-title');

            // 找出目前生效的時間區段
            const currentEvent = [...RHYTHM_TIMELINE].reverse().find(e => time >= e.time);

            if (currentEvent) {
                // 回合切換 (Time-based fallback)
                // If we are significantly past the start time, ensure we are on the right round.
                // But if we just flipped early, we don't want to revert or re-trigger.
                // The Timeline 'round' property is authoritative.
                // If we flipped early, GAME_STATE.currentRound IS already nextRoundIdx.
                // So if currentEvent.round matches, good.
                // The tricky part: R1 ends at 8.0s. We flip to R2.
                // Current time is 8.5s. currentEvent is still R1 (timeline: 5.3s).
                // So currentEvent.round is 0. GAME_STATE.currentRound is 1.
                // If we execute: `if (currentEvent.round !== GAME_STATE.currentRound) setRound(currentEvent.round)`
                // It will SET IT BACK to 0!
                // FIX: We must Ignore Time-based round setting if we are in the "Early Flip" period.
                // OR: We only set round if the Beat Index is low (start of round)?

                if (currentEvent.action === 'start') {
                    // 計算該回合啟動後的經過時間
                    const elapsedTime = time - currentEvent.time;
                    const beatIndex = Math.floor(elapsedTime / BEAT_DURATION);

                    // Start of round sync (only if we are NOT in the finished state of PREVIOUS round, which is impossible if `currentEvent` changed)
                    // Logic: If beatIndex is < 8, we MUST be on `currentEvent.round`.
                    // If beatIndex >= 8, we MIGHT be on next round (Early Flip).

                    if (beatIndex < 8 && GAME_STATE.currentRound !== currentEvent.round) {
                        setRound(currentEvent.round);
                    }

                    // 邏輯: 每一輪只閃爍 8 次 (0~7)
                    if (beatIndex < 8) {
                        GAME_STATE.hasFlippedForThisRound = false;

                        if (beatIndex !== GAME_STATE.lastBeat) {
                            GAME_STATE.lastBeat = beatIndex;
                            updateRhythmEffect(beatIndex);

                            // Pump Title
                            if (beatIndex % 2 === 0) { // 強拍
                                title.style.opacity = '1';
                                title.style.transform = 'scale(1.1)';
                            } else {
                                title.style.opacity = '0.7';
                                title.style.transform = 'scale(1)';
                            }
                        }
                    } else {
                        // 超過8拍，停止閃爍
                        if (GAME_STATE.lastBeat !== -1) {
                            updateRhythmEffect(-1);
                            GAME_STATE.lastBeat = -1;
                            title.style.opacity = '0.5';
                            title.style.transform = 'scale(1)';

                            // --- EARLY SWITCH TRIGGER ---
                            const nextRoundIdx = currentEvent.round + 1;
                            // Ensure next round exists AND we haven't flipped yet
                            // Note: currentEvent.round comes from timeline.
                            if (nextRoundIdx < TOTAL_ROUNDS && !GAME_STATE.hasFlippedForThisRound) {
                                prepareFlipContent(nextRoundIdx);
                                // Small delay before flipping
                                setTimeout(() => {
                                    triggerFlip();
                                    GAME_STATE.currentRound = nextRoundIdx;
                                    updateRoundButtons();
                                }, 500);
                                GAME_STATE.hasFlippedForThisRound = true;
                            }
                        }
                    }
                } else {
                    updateRhythmEffect(-1);
                }
            } else {
                updateRhythmEffect(-1);
            }
        }

        function updateRhythmEffect(slotIndex) {
            document.querySelectorAll('.grid-item').forEach(el => el.classList.remove('active'));
            if (slotIndex !== -1) {
                const targetSlot = document.getElementById(`slot-${slotIndex}`);
                if (targetSlot) targetSlot.classList.add('active');
            }
        }

        document.getElementById('play-btn').addEventListener('click', () => {
            if (GAME_STATE.isPlaying) player.pauseVideo();
            else player.playVideo();
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            if (player && player.seekTo) {
                player.seekTo(0);
                player.pauseVideo();
                GAME_STATE.lastBeat = -1;
                setRound(0);
                updateRhythmEffect(-1);
                // document.getElementById('timer-display').innerText = "TIME: 0.00s";
            }
        });

        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        init();
    </script>
</body>

</html>
